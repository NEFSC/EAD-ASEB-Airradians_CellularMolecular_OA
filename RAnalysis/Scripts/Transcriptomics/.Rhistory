dplyr::mutate(FrontMod_color =
ifelse(ResponseRatio > 1.0 &
ControlRatio < 1.0, "True", "False")) %>%
# dplyr::filter(ControlRatio < 5) %>%
# dplyr::filter(ResponseRatioHigh <1.2) %>%
ggplot(aes(x=ResponseRatio, y=ControlRatio)) +
geom_point(aes(color='grey80', na.rm=TRUE)) +
scale_shape_manual(values=c(19,19)) +
scale_color_manual(values=c("grey", "black")) +
theme_classic() +
scale_x_continuous(expand = c(0, 0), limits = c(0.9,1.1)) +
scale_y_continuous(expand = c(0, 0), limits = c(0.95,1.1)) +
stat_smooth(method = "lm",
formula = y ~ x + poly(x, 2) - 1) +
geom_vline(xintercept=1, linetype="dotted") +
geom_hline(yintercept=1, linetype="dotted") +
labs(y= "Control ratio, under matched pCO2",
x = "Response ratio, under mismatched pCO2",
title = "Frontloading criteria (shaded)") +
expand_limits(x = 1.1, y = 1.1) +
annotate("rect", xmin = .9, xmax = 1, ymin = 1, ymax = 1.1,
alpha = .2) +
theme(legend.position="none", text = element_text(size=10))
Frontloading_plot_2.2
# call the unique frontloaded genes
WGCNA_frontloaded_2.2 <- unique(merge((df_total_2.2 %>% filter(Frontloaded_criteria == 'frontloaded')),
AirrdiansTranscript_Proteinnames_2, by = 'Airradians.TranscriptID'))
# truncate df_total for only genes assigned as 'frontloaded' from modules red and salmon
Frontloaded_AirradiansTranscriptIDs <- merge((df_total_2.2 %>% filter(Frontloaded_criteria == 'frontloaded')),
AirrdiansTranscript_Proteinnames_2,
by = c('Protein_name','Airradians.TranscriptID'))
# truncate the vst Exp means (mean exp for each gene within pCO2 history * pCO2 exposure, N = 5 each)
IDtargets                           <- vstExp_ChallengeDOWN.long.meta.means %>%
dplyr::filter(Airradians.TranscriptID %in%
unique(Frontloaded_AirradiansTranscriptIDs$Airradians.TranscriptID))
IDtargets_stats <- IDtargets %>%
dplyr::mutate(MatchMismatch = case_when(
(pCO2_history %in% 'low'    & pCO2_exposure %in% 'low')    ~ "match",
(pCO2_history %in% 'severe' & pCO2_exposure %in% 'severe') ~ "match",
(pCO2_history %in% 'low'    & pCO2_exposure %in% 'severe') ~ "mismatch",
(pCO2_history %in% 'severe' & pCO2_exposure %in% 'low')    ~ "mismatch",TRUE ~ NA
)) %>%
dplyr::filter(MatchMismatch %in% c('match', 'mismatch'))
AOVmod <- lm(mean.vstExp~pCO2_history*MatchMismatch,data=IDtargets_stats)
shapiro.test(resid(AOVmod)) # p-value < 2.2e-16
SRHmod <- scheirerRayHare(mean.vstExp~pCO2_history*MatchMismatch,data=IDtargets_stats)
### Dunn test
library(FSA)
SRHmod
plotting <- IDtargets_stats %>% group_by(pCO2_history, MatchMismatch) %>%
dplyr::summarise(mean_meanvstExp = mean(mean.vstExp),
sd_vstExp = sd(mean.vstExp),
n = n(),
se_vstExp = sd_vstExp / sqrt(n)
)
nrow(Frontloaded_AirradiansTranscriptIDs) # 496
Frontloading_MEAN.SE_2.2 <- plotting %>%
# dplyr::filter(pCO2_exposure %in% c('low', 'moderate')) %>%
dplyr::filter(MatchMismatch %in% c('match', 'mismatch')) %>%
ggplot(aes(x=MatchMismatch, y = mean_meanvstExp, fill=pCO2_history)) +
geom_point(aes(shape=pCO2_history, fill=pCO2_history),
size = 4.5,position=position_dodge(.4)) +
geom_line() +
theme_classic() +
labs(y= "vst expression",
x = "pCO2 exposure",
title = "Frontloaded genes (N = 438)") +
geom_errorbar(aes(ymin=(mean_meanvstExp)-(se_vstExp), # new means and se by treatment
ymax=(mean_meanvstExp)+(se_vstExp)), # new means and se by treatment
width=0,position=position_dodge(.4)) # width determines the length of the end ticks
Frontloading_MEAN.SE_2.2
loop_df    <- as.data.frame(unique(vstExp_ChallengeDOWN.long.meta.means$Airradians.TranscriptID))
# loop_df    <- as.data.frame(unique(rlogExp_Challenge.long.meta.means$Airradians.TranscriptID))
loop.table <- data.frame(matrix(nrow = 1, ncol = 9)) # create dataframe to save cumunalitively during for loop
colnames(loop.table)<-c('Airradians.TranscriptID',
'Protein_name',
'baseMeanNAIVE_control',
'baseMeanHABITUATED_control',
'baseMeanNAIVE_response',
'baseMeanHABITUATED_response',
'ControlRatio',
'ResponseRatio',
'Frontloaded_criteria')
df_total_2.2 <- data.frame() # start dataframe
for (i in 1:nrow(loop_df)) {
df_loop <- vstExp_ChallengeDOWN.long.meta.means %>% filter(Airradians.TranscriptID %in% loop_df[i,])
if (nrow(df_loop) == 6) {
loop.table$Airradians.TranscriptID     <- loop_df[i,]
loop.table$Protein_name                <- df_loop$Protein_name[1]
# contrl - their matched condition
loop.table$baseMeanNAIVE_control       <- (df_loop %>% dplyr::filter(pCO2_exposure %in% 'low' &
pCO2_history %in% 'low'))$mean.vstExp
loop.table$baseMeanHABITUATED_control  <- (df_loop %>% dplyr::filter(pCO2_exposure %in% 'severe' &
pCO2_history %in% 'severe'))$mean.vstExp
# response - their mismatched condition
loop.table$baseMeanNAIVE_response      <- (df_loop %>% dplyr::filter(pCO2_exposure %in% 'moderate' & # how do low respond to high
pCO2_history %in% 'low'))$mean.vstExp
loop.table$baseMeanHABITUATED_response <- (df_loop %>% dplyr::filter(pCO2_exposure %in% 'moderate' & # how to high responds to low
pCO2_history %in% 'severe'))$mean.vstExp
# reverse it for down reg- naive over the habituated
# > 1 = higher expression by naive animals in response their control/ matched condition, lower baseline expression by habituated
# the vast majoirty are going to be here given this is the main criteria for choosing green and pink modules
loop.table$ControlRatio                <- loop.table$baseMeanNAIVE_control / loop.table$baseMeanHABITUATED_control
# reverse it for downreg -  Naive over habituated
# < 1 means that the habituated animals have a stronger response to mismatch
loop.table$ResponseRatio           <- ( abs(1-(loop.table$baseMeanNAIVE_response /
loop.table$baseMeanNAIVE_control)) /
abs(1-(loop.table$baseMeanHABITUATED_response /
loop.table$baseMeanHABITUATED_control)) )
loop.table <- loop.table %>%
dplyr::mutate(Frontloaded_criteria =
case_when(
ControlRatio > 1 &
ResponseRatio < 1 ~ "frontloaded",
ControlRatio < 1 &
ResponseRatio < 1 ~ "high expression relative to naive",
# ControlRatio < 1 &
ResponseRatio > 1 ~ "less responsive relative to naive"))
} else {NA}
df <- data.frame(loop.table) # name dataframe for this singl e row
df_total_2.2 <- rbind(df_total_2.2, df) #bind to a cumulative list dataframe
}
#Plot the criteria
Frontloading_plot_2.2 <- df_total_2.2 %>%
dplyr::mutate(FrontMod_color =
ifelse(ResponseRatio > 1.0 &
ControlRatio < 1.0, "True", "False")) %>%
# dplyr::filter(ControlRatio < 5) %>%
# dplyr::filter(ResponseRatioHigh <1.2) %>%
ggplot(aes(x=ResponseRatio, y=ControlRatio)) +
geom_point(aes(color='grey80', na.rm=TRUE)) +
scale_shape_manual(values=c(19,19)) +
scale_color_manual(values=c("grey", "black")) +
theme_classic() +
scale_x_continuous(expand = c(0, 0), limits = c(0.9,1.1)) +
scale_y_continuous(expand = c(0, 0), limits = c(0.95,1.1)) +
stat_smooth(method = "lm",
formula = y ~ x + poly(x, 2) - 1) +
geom_vline(xintercept=1, linetype="dotted") +
geom_hline(yintercept=1, linetype="dotted") +
labs(y= "Control ratio, under matched pCO2",
x = "Response ratio, under mismatched pCO2",
title = "Frontloading criteria (shaded)") +
expand_limits(x = 1.1, y = 1.1) +
annotate("rect", xmin = .9, xmax = 1, ymin = 1, ymax = 1.1,
alpha = .2) +
theme(legend.position="none", text = element_text(size=10))
# call the unique frontloaded genes
WGCNA_frontloaded_2.2 <- unique(merge((df_total_2.2 %>% filter(Frontloaded_criteria == 'frontloaded')),
AirrdiansTranscript_Proteinnames_2, by = 'Airradians.TranscriptID'))
# truncate df_total for only genes assigned as 'frontloaded' from modules red and salmon
Frontloaded_AirradiansTranscriptIDs <- merge((df_total_2.2 %>% filter(Frontloaded_criteria == 'frontloaded')),
AirrdiansTranscript_Proteinnames_2,
by = c('Protein_name','Airradians.TranscriptID'))
# truncate the vst Exp means (mean exp for each gene within pCO2 history * pCO2 exposure, N = 5 each)
IDtargets                           <- vstExp_ChallengeDOWN.long.meta.means %>%
dplyr::filter(Airradians.TranscriptID %in%
unique(Frontloaded_AirradiansTranscriptIDs$Airradians.TranscriptID))
IDtargets_stats <- IDtargets %>%
dplyr::mutate(MatchMismatch = case_when(
(pCO2_history %in% 'low'    & pCO2_exposure %in% 'low')    ~ "match",
(pCO2_history %in% 'severe' & pCO2_exposure %in% 'severe') ~ "match",
(pCO2_history %in% 'low'    & pCO2_exposure %in% 'moderate') ~ "mismatch",
(pCO2_history %in% 'severe' & pCO2_exposure %in% 'moderate') ~ "mismatch",TRUE ~ NA
)) %>%
dplyr::filter(MatchMismatch %in% c('match', 'mismatch'))
IDtargets_stats <- IDtargets %>%
dplyr::mutate(MatchMismatch = case_when(
(pCO2_history %in% 'low'    & pCO2_exposure %in% 'low')    ~ "match",
(pCO2_history %in% 'severe' & pCO2_exposure %in% 'severe') ~ "match",
(pCO2_history %in% 'low'    & pCO2_exposure %in% 'moderate') ~ "mismatch",
(pCO2_history %in% 'severe' & pCO2_exposure %in% 'moderate') ~ "mismatch",TRUE ~ NA
)) %>%
dplyr::filter(MatchMismatch %in% c('match', 'mismatch'))
AOVmod <- lm(mean.vstExp~pCO2_history*MatchMismatch,data=IDtargets_stats)
shapiro.test(resid(AOVmod)) # p-value < 2.2e-16
SRHmod <- scheirerRayHare(mean.vstExp~pCO2_history*MatchMismatch,data=IDtargets_stats)
SRHmod
plotting <- IDtargets_stats %>% group_by(pCO2_history, MatchMismatch) %>%
dplyr::summarise(mean_meanvstExp = mean(mean.vstExp),
sd_vstExp = sd(mean.vstExp),
n = n(),
se_vstExp = sd_vstExp / sqrt(n)
)
nrow(Frontloaded_AirradiansTranscriptIDs) # 496
Frontloading_MEAN.SE_2.2 <- plotting %>%
# dplyr::filter(pCO2_exposure %in% c('low', 'moderate')) %>%
dplyr::filter(MatchMismatch %in% c('match', 'mismatch')) %>%
ggplot(aes(x=MatchMismatch, y = mean_meanvstExp, fill=pCO2_history)) +
geom_point(aes(shape=pCO2_history, fill=pCO2_history),
size = 4.5,position=position_dodge(.4)) +
geom_line() +
theme_classic() +
labs(y= "vst expression",
x = "pCO2 exposure",
title = "Frontloaded genes (N = 438)") +
geom_errorbar(aes(ymin=(mean_meanvstExp)-(se_vstExp), # new means and se by treatment
ymax=(mean_meanvstExp)+(se_vstExp)), # new means and se by treatment
width=0,position=position_dodge(.4)) # width determines the length of the end ticks
Frontloading_MEAN.SE_2.2
loop_df    <- as.data.frame(unique(vstExp_ChallengeDOWN.long.meta.means$Airradians.TranscriptID))
# loop_df    <- as.data.frame(unique(rlogExp_Challenge.long.meta.means$Airradians.TranscriptID))
loop.table <- data.frame(matrix(nrow = 1, ncol = 9)) # create dataframe to save cumunalitively during for loop
colnames(loop.table)<-c('Airradians.TranscriptID',
'Protein_name',
'baseMeanNAIVE_control',
'baseMeanHABITUATED_control',
'baseMeanNAIVE_response',
'baseMeanHABITUATED_response',
'ControlRatio',
'ResponseRatio',
'Frontloaded_criteria')
df_total_2.2 <- data.frame() # start dataframe
for (i in 1:nrow(loop_df)) {
df_loop <- vstExp_ChallengeDOWN.long.meta.means %>% filter(Airradians.TranscriptID %in% loop_df[i,])
if (nrow(df_loop) == 6) {
loop.table$Airradians.TranscriptID     <- loop_df[i,]
loop.table$Protein_name                <- df_loop$Protein_name[1]
# contrl - their matched condition
loop.table$baseMeanNAIVE_control       <- (df_loop %>% dplyr::filter(pCO2_exposure %in% 'low' &
pCO2_history %in% 'low'))$mean.vstExp
loop.table$baseMeanHABITUATED_control  <- (df_loop %>% dplyr::filter(pCO2_exposure %in% 'severe' &
pCO2_history %in% 'severe'))$mean.vstExp
# response - their mismatched condition
loop.table$baseMeanNAIVE_response      <- (df_loop %>% dplyr::filter(pCO2_exposure %in% 'moderate' & # how do low respond to high
pCO2_history %in% 'low'))$mean.vstExp
loop.table$baseMeanHABITUATED_response <- (df_loop %>% dplyr::filter(pCO2_exposure %in% 'moderate' & # how to high responds to low
pCO2_history %in% 'severe'))$mean.vstExp
# reverse it for down reg- naive over the habituated
# > 1 = higher expression by naive animals in response their control/ matched condition, lower baseline expression by habituated
# the vast majoirty are going to be here given this is the main criteria for choosing green and pink modules
loop.table$ControlRatio                <- loop.table$baseMeanNAIVE_control / loop.table$baseMeanHABITUATED_control
# reverse it for downreg -  Naive over habituated
# < 1 means that the habituated animals have a stronger response to mismatch
# loop.table$ResponseRatio           <- ( abs(1-(loop.table$baseMeanNAIVE_response /
#                                               loop.table$baseMeanNAIVE_control)) /
#
#                                           abs(1-(loop.table$baseMeanHABITUATED_response /
#                                               loop.table$baseMeanHABITUATED_control)) )
loop.table$ResponseRatio           <- ( (loop.table$baseMeanNAIVE_response /
loop.table$baseMeanNAIVE_control) /
(loop.table$baseMeanHABITUATED_response /
loop.table$baseMeanHABITUATED_control) )
loop.table <- loop.table %>%
dplyr::mutate(Frontloaded_criteria =
case_when(
ControlRatio > 1 &
ResponseRatio < 1 ~ "frontloaded",
ControlRatio < 1 &
ResponseRatio < 1 ~ "high expression relative to naive",
# ControlRatio < 1 &
ResponseRatio > 1 ~ "less responsive relative to naive"))
} else {NA}
df <- data.frame(loop.table) # name dataframe for this singl e row
df_total_2.2 <- rbind(df_total_2.2, df) #bind to a cumulative list dataframe
}
#Plot the criteria
Frontloading_plot_2.2 <- df_total_2.2 %>%
dplyr::mutate(FrontMod_color =
ifelse(ResponseRatio > 1.0 &
ControlRatio < 1.0, "True", "False")) %>%
# dplyr::filter(ControlRatio < 5) %>%
# dplyr::filter(ResponseRatioHigh <1.2) %>%
ggplot(aes(x=ResponseRatio, y=ControlRatio)) +
geom_point(aes(color='grey80', na.rm=TRUE)) +
scale_shape_manual(values=c(19,19)) +
scale_color_manual(values=c("grey", "black")) +
theme_classic() +
scale_x_continuous(expand = c(0, 0), limits = c(0.9,1.1)) +
scale_y_continuous(expand = c(0, 0), limits = c(0.95,1.1)) +
stat_smooth(method = "lm",
formula = y ~ x + poly(x, 2) - 1) +
geom_vline(xintercept=1, linetype="dotted") +
geom_hline(yintercept=1, linetype="dotted") +
labs(y= "Control ratio, under matched pCO2",
x = "Response ratio, under mismatched pCO2",
title = "Frontloading criteria (shaded)") +
expand_limits(x = 1.1, y = 1.1) +
annotate("rect", xmin = .9, xmax = 1, ymin = 1, ymax = 1.1,
alpha = .2) +
theme(legend.position="none", text = element_text(size=10))
Frontloading_plot_2.2
# call the unique frontloaded genes
WGCNA_frontloaded_2.2 <- unique(merge((df_total_2.2 %>% filter(Frontloaded_criteria == 'frontloaded')),
AirrdiansTranscript_Proteinnames_2, by = 'Airradians.TranscriptID'))
# truncate df_total for only genes assigned as 'frontloaded' from modules red and salmon
Frontloaded_AirradiansTranscriptIDs <- merge((df_total_2.2 %>% filter(Frontloaded_criteria == 'frontloaded')),
AirrdiansTranscript_Proteinnames_2,
by = c('Protein_name','Airradians.TranscriptID'))
# truncate the vst Exp means (mean exp for each gene within pCO2 history * pCO2 exposure, N = 5 each)
IDtargets                           <- vstExp_ChallengeDOWN.long.meta.means %>%
dplyr::filter(Airradians.TranscriptID %in%
unique(Frontloaded_AirradiansTranscriptIDs$Airradians.TranscriptID))
IDtargets_stats <- IDtargets %>%
dplyr::mutate(MatchMismatch = case_when(
(pCO2_history %in% 'low'    & pCO2_exposure %in% 'low')    ~ "match",
(pCO2_history %in% 'severe' & pCO2_exposure %in% 'severe') ~ "match",
(pCO2_history %in% 'low'    & pCO2_exposure %in% 'moderate') ~ "mismatch",
(pCO2_history %in% 'severe' & pCO2_exposure %in% 'moderate') ~ "mismatch",TRUE ~ NA
)) %>%
dplyr::filter(MatchMismatch %in% c('match', 'mismatch'))
AOVmod <- lm(mean.vstExp~pCO2_history*MatchMismatch,data=IDtargets_stats)
shapiro.test(resid(AOVmod)) # p-value < 2.2e-16
SRHmod <- scheirerRayHare(mean.vstExp~pCO2_history*MatchMismatch,data=IDtargets_stats)
SRHmod
plotting <- IDtargets_stats %>% group_by(pCO2_history, MatchMismatch) %>%
dplyr::summarise(mean_meanvstExp = mean(mean.vstExp),
sd_vstExp = sd(mean.vstExp),
n = n(),
se_vstExp = sd_vstExp / sqrt(n)
)
nrow(Frontloaded_AirradiansTranscriptIDs) # 496
Frontloading_MEAN.SE_2.2 <- plotting %>%
# dplyr::filter(pCO2_exposure %in% c('low', 'moderate')) %>%
dplyr::filter(MatchMismatch %in% c('match', 'mismatch')) %>%
ggplot(aes(x=MatchMismatch, y = mean_meanvstExp, fill=pCO2_history)) +
geom_point(aes(shape=pCO2_history, fill=pCO2_history),
size = 4.5,position=position_dodge(.4)) +
geom_line() +
theme_classic() +
labs(y= "vst expression",
x = "pCO2 exposure",
title = "Frontloaded genes (N = 438)") +
geom_errorbar(aes(ymin=(mean_meanvstExp)-(se_vstExp), # new means and se by treatment
ymax=(mean_meanvstExp)+(se_vstExp)), # new means and se by treatment
width=0,position=position_dodge(.4)) # width determines the length of the end ticks
Frontloading_MEAN.SE_2.2
nrow(Frontloaded_AirradiansTranscriptIDs) # 496
pdf("Output/Transcriptomics/WGCNA/challenge/Frontloading/DOWNmodulegreenpink_Moderate.pdf", height=4, width =8)
knitr::opts_knit$set(root.dir = "C:/Users/samjg/Documents/Github_repositories/Airradians_CellularMolecular_OA/RAnalysis")
pdf("Output/Transcriptomics/WGCNA/challenge/Frontloading/DOWNmodulegreenpink_Moderate.pdf", height=4, width =8)
ggarrange(Frontloading_plot_2.2, Frontloading_MEAN.SE_2.2, ncol=2)
dev.off()
ggarrange(Frontloading_plot_2.2, Frontloading_MEAN.SE_2.2, ncol=2)
write.csv(Frontloaded_AirradiansTranscriptIDs,
file = "Output/Transcriptomics/WGCNA/challenge/Frontloading/DOWNmodulegreenpink_Moderate.csv")
knitr::opts_chunk$set(echo = TRUE,
warning = FALSE,
message = FALSE,
cache = TRUE)
knitr::opts_knit$set(root.dir = "C:/Users/samjg/Documents/Github_repositories/Airradians_CellularMolecular_OA/RAnalysis")
library(dplyr)
library(reshape2)
library(ggplot2)
library(kableExtra)
library(knitr)
library(tidyverse)
library(DESeq2)
library(plotrix)
library(ggpubr)
# load data and read in the module membership master file
load(file = "Output/Transcriptomics/WGCNA/challenge/Challenge-networkConstruction-stepByStep.RData")
Challenge_ModuleMembership  <- read.csv(file="Output/Transcriptomics/WGCNA/challenge/Challenge_WGCNA_ModulMembership.csv",
sep=',', header=TRUE)
# MASTER REF
# reference Cvirginica KEGG IDs (contains )
Cvirg_KEGGIDs_Ref   <- read.csv(file = "Data/Transcriptomics/metadata/Seq_Cvirg_Reference.csv",header = T)
# diamond bastx output of Airradians genome with Cvirg query
Airr_Cvirg_diamond   <- read.csv(file = "Data/Transcriptomics/metadata/seq_id_AirrCvirg_MERGED_master.csv",header = T) %>%
dplyr::rename('Cvirginica_TranscriptID' = 'blastxEval_CvirgTranscriptID') %>%
dplyr::select('Airradians_TranscriptID',
'Cvirginica_TranscriptID')
Airr_Cvirg_Cgig_KEGG <- merge(Cvirg_KEGGIDs_Ref, Airr_Cvirg_diamond, by = 'Cvirginica_TranscriptID') %>%
dplyr::rename(Airradians.TranscriptID = Airradians_TranscriptID,
Protein_name = Cvirginica_Protein_name)
AirrdiansTranscript_Proteinnames <- Challenge_ModuleMembership %>% dplyr::select(Airradians.TranscriptID)
nrow(Airr_Cvirg_Cgig_KEGG)
AirrdiansTranscript_Proteinnames_2 <- (merge(AirrdiansTranscript_Proteinnames, Airr_Cvirg_Cgig_KEGG, by = "Airradians.TranscriptID", all = TRUE))
# transpose the vst challenge data used for WGCNa (jas 27 samples - truncated from sample tree (view WGCNA.Rmd)
vstExp_Challenge  <- as.data.frame(t(dds_1filt_master)) # this is our vst master file we used for WGCNA
vstExp_Challenge  <- tibble::rownames_to_column(vstExp_Challenge,"Airradians.TranscriptID") # rownames as first column
ncol(vstExp_Challenge) # 27 + AirradiansID
# write out this rlog tranformed master data (used for plotting below1)
rlogExp_Challenge <- read.csv(file = "Output/Transcriptomics/WGCNA/challenge/Challenge_rlog_transformed.csv", sep=',', header=TRUE) %>%
dplyr::select(!X)
ncol(rlogExp_Challenge) # 27 + AirradiansID
modulesGreenPink_Airradians.IDs      <- (Challenge_ModuleMembership %>% dplyr::filter(moduleColor %in%
c('green','pink')))$Airradians.TranscriptID
length(modulesGreenPink_Airradians.IDs) # 1087
#vst
vstExp_ChallengeDOWN.long              <- vstExp_Challenge %>%
dplyr::filter(Airradians.TranscriptID %in% modulesGreenPink_Airradians.IDs) %>%
pivot_longer(
cols = !c(Airradians.TranscriptID),
names_to = "Sample_num",
values_to = "vstExp"
)
nrow(vstExp_ChallengeDOWN.long) # 29160
vstExp_ChallengeDOWN.long.merge        <- merge(vstExp_ChallengeDOWN.long, AirrdiansTranscript_Proteinnames_2, by = 'Airradians.TranscriptID')
vstExp_ChallengeDOWN.long.meta         <- cbind(vstExp_ChallengeDOWN.long.merge, exp_metadata_1_master, by = "Sample_num")
vstExp_ChallengeDOWN.long.meta.means   <- vstExp_ChallengeDOWN.long.meta %>%
dplyr::select(c(vstExp, pCO2_exposure,pCO2_history,
Airradians.TranscriptID, Protein_name)) %>%
dplyr::group_by(pCO2_exposure, pCO2_history,
Airradians.TranscriptID, Protein_name) %>%
dplyr::summarise(mean.vstExp = mean(vstExp), n = n())
nrow(vstExp_ChallengeDOWN.long.meta.means) # 6480
length(unique(vstExp_ChallengeDOWN.long.meta.means$Airradians.TranscriptID)) # 1080
loop_df    <- as.data.frame(unique(vstExp_ChallengeDOWN.long.meta.means$Airradians.TranscriptID))
# loop_df    <- as.data.frame(unique(rlogExp_Challenge.long.meta.means$Airradians.TranscriptID))
loop.table <- data.frame(matrix(nrow = 1, ncol = 9)) # create dataframe to save cumunalitively during for loop
colnames(loop.table)<-c('Airradians.TranscriptID',
'Protein_name',
'baseMeanNAIVE_control',
'baseMeanHABITUATED_control',
'baseMeanNAIVE_response',
'baseMeanHABITUATED_response',
'ControlRatio',
'ResponseRatio',
'Frontloaded_criteria')
df_total_2.2 <- data.frame() # start dataframe
loop_df    <- as.data.frame(unique(vstExp_ChallengeDOWN.long.meta.means$Airradians.TranscriptID))
# loop_df    <- as.data.frame(unique(rlogExp_Challenge.long.meta.means$Airradians.TranscriptID))
loop.table <- data.frame(matrix(nrow = 1, ncol = 9)) # create dataframe to save cumunalitively during for loop
colnames(loop.table)<-c('Airradians.TranscriptID',
'Protein_name',
'baseMeanNAIVE_control',
'baseMeanHABITUATED_control',
'baseMeanNAIVE_response',
'baseMeanHABITUATED_response',
'ControlRatio',
'ResponseRatio',
'Frontloaded_criteria')
df_total_2.2 <- data.frame() # start dataframe
for (i in 1:nrow(loop_df)) {
df_loop <- vstExp_ChallengeDOWN.long.meta.means %>% filter(Airradians.TranscriptID %in% loop_df[i,])
if (nrow(df_loop) == 6) {
loop.table$Airradians.TranscriptID     <- loop_df[i,]
loop.table$Protein_name                <- df_loop$Protein_name[1]
# contrl - their matched condition
loop.table$baseMeanNAIVE_control       <- (df_loop %>% dplyr::filter(pCO2_exposure %in% 'low' &
pCO2_history %in% 'low'))$mean.vstExp
loop.table$baseMeanHABITUATED_control  <- (df_loop %>% dplyr::filter(pCO2_exposure %in% 'severe' &
pCO2_history %in% 'severe'))$mean.vstExp
# response - their mismatched condition
loop.table$baseMeanNAIVE_response      <- (df_loop %>% dplyr::filter(pCO2_exposure %in% 'moderate' & # how do low respond to high
pCO2_history %in% 'low'))$mean.vstExp
loop.table$baseMeanHABITUATED_response <- (df_loop %>% dplyr::filter(pCO2_exposure %in% 'moderate' & # how to high responds to low
pCO2_history %in% 'severe'))$mean.vstExp
# reverse it for down reg- naive over the habituated
# > 1 = higher expression by naive animals in response their control/ matched condition, lower baseline expression by habituated
# the vast majoirty are going to be here given this is the main criteria for choosing green and pink modules
loop.table$ControlRatio                <- loop.table$baseMeanNAIVE_control / loop.table$baseMeanHABITUATED_control
# reverse it for downreg -  Naive over habituated
# < 1 means that the habituated animals have a stronger response to mismatch
# loop.table$ResponseRatio           <- ( abs(1-(loop.table$baseMeanNAIVE_response /
#                                               loop.table$baseMeanNAIVE_control)) /
#
#                                           abs(1-(loop.table$baseMeanHABITUATED_response /
#                                               loop.table$baseMeanHABITUATED_control)) )
loop.table$ResponseRatio           <- ( (loop.table$baseMeanNAIVE_response /
loop.table$baseMeanNAIVE_control) /
(loop.table$baseMeanHABITUATED_response /
loop.table$baseMeanHABITUATED_control) )
loop.table <- loop.table %>%
dplyr::mutate(Frontloaded_criteria =
case_when(
ControlRatio > 1 &
ResponseRatio > 1 ~ "frontloaded",
ControlRatio < 1 &
ResponseRatio < 1 ~ "high expression relative to naive"))
} else {NA}
df <- data.frame(loop.table) # name dataframe for this singl e row
df_total_2.2 <- rbind(df_total_2.2, df) #bind to a cumulative list dataframe
}
# call the unique frontloaded genes
WGCNA_frontloaded_2.2 <- unique(merge((df_total_2.2 %>% filter(Frontloaded_criteria == 'frontloaded')),
AirrdiansTranscript_Proteinnames_2, by = 'Airradians.TranscriptID'))
# truncate df_total for only genes assigned as 'frontloaded' from modules red and salmon
Frontloaded_AirradiansTranscriptIDs <- merge((df_total_2.2 %>% filter(Frontloaded_criteria == 'frontloaded')),
AirrdiansTranscript_Proteinnames_2,
by = c('Protein_name','Airradians.TranscriptID'))
# truncate the vst Exp means (mean exp for each gene within pCO2 history * pCO2 exposure, N = 5 each)
IDtargets                           <- vstExp_ChallengeDOWN.long.meta.means %>%
dplyr::filter(Airradians.TranscriptID %in%
unique(Frontloaded_AirradiansTranscriptIDs$Airradians.TranscriptID))
IDtargets_stats <- IDtargets %>%
dplyr::mutate(MatchMismatch = case_when(
(pCO2_history %in% 'low'    & pCO2_exposure %in% 'low')    ~ "match",
(pCO2_history %in% 'severe' & pCO2_exposure %in% 'severe') ~ "match",
(pCO2_history %in% 'low'    & pCO2_exposure %in% 'moderate') ~ "mismatch",
(pCO2_history %in% 'severe' & pCO2_exposure %in% 'moderate') ~ "mismatch",TRUE ~ NA
)) %>%
dplyr::filter(MatchMismatch %in% c('match', 'mismatch'))
AOVmod <- lm(mean.vstExp~pCO2_history*MatchMismatch,data=IDtargets_stats)
shapiro.test(resid(AOVmod)) # p-value < 2.2e-16
SRHmod <- scheirerRayHare(mean.vstExp~pCO2_history*MatchMismatch,data=IDtargets_stats)
library(rcompanion)
SRHmod <- scheirerRayHare(mean.vstExp~pCO2_history*MatchMismatch,data=IDtargets_stats)
SRHmod
plotting <- IDtargets_stats %>% group_by(pCO2_history, MatchMismatch) %>%
dplyr::summarise(mean_meanvstExp = mean(mean.vstExp),
sd_vstExp = sd(mean.vstExp),
n = n(),
se_vstExp = sd_vstExp / sqrt(n)
)
nrow(Frontloaded_AirradiansTranscriptIDs) # 438
Frontloading_MEAN.SE_2.2 <- plotting %>%
# dplyr::filter(pCO2_exposure %in% c('low', 'moderate')) %>%
dplyr::filter(MatchMismatch %in% c('match', 'mismatch')) %>%
ggplot(aes(x=MatchMismatch, y = mean_meanvstExp, fill=pCO2_history)) +
geom_point(aes(shape=pCO2_history, fill=pCO2_history),
size = 4.5,position=position_dodge(.4)) +
geom_line() +
theme_classic() +
labs(y= "vst expression",
x = "pCO2 exposure",
title = "Frontloaded genes (N = 438)") +
geom_errorbar(aes(ymin=(mean_meanvstExp)-(se_vstExp), # new means and se by treatment
ymax=(mean_meanvstExp)+(se_vstExp)), # new means and se by treatment
width=0,position=position_dodge(.4)) # width determines the length of the end ticks
Frontloading_MEAN.SE_2.2
